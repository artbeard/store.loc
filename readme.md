# Постановка задачи
Из условия понятно, что требуется приложение учета для склада. Оно
будет реализовывать две задачи - учет прихода и расхода материальных активов, а так же собрить предзаказы на товар из магазина.

# Обоснование решения
Поскольку товаров немного, а политики распределения товаров от цены поставки не определены в условии
(например, какие товары из какой поставки продавать вперед, более дорогие или более дешевые,
ведь у некоторых товаров есть сроки хранения и т.д. и т.п.), будем использовать номенклатурный (сортовой)
метод учета.
Учет количества/стоимости будет аддитивным, для расходных операций цена единицы будет равна средней
цене позиции. Основой всей учетной системы будет карточка товара - запись в таблице (product), характеризующая товар.

Для учета потребуется таблица, содержащая проводки (statement) (входящие со знаком +, исходящие - со знаком -),
таким образом, сальдо на определенную дату будет вычисляться суммированием по столбцам для каждого товара.
Такой метод с ростом количества проводок будет вызывать нагрузку на бд. Можно было бы добавлять итоговые значения к
каждой проводке, но это нарушит 2НФ. Заведем еще одну таблицу (balance), которая будет содержать ссылку на продукт и
значения цены и стоимости по каждой затрагиваемой проводкой позиции на текущую дату.

Эта небольшая издержка (таблица balance) значительно сократит объем и снизит нагрузку на БД.

Несколько слов о сальдо.  Ввиду того, что не все позиции затрагиваются проводками каждый день,
не получится брать простой выборкой сальдо по всем позициям на определенную дату. Критерий выборки по каждой
позиции - максимальная дата изменения баланса, но не превышающая текущую (важно при просмотре истории).
Наиболее удобно и экономно сделать такую выборку за один запрос:
```sql
SELECT
    product.id, product.name, balance.cost, balance.amount, balance.balance_at
FROM
    product
INNER JOIN
    (
        SELECT product_id, MAX(balance_at) as max_balance_at
        FROM balance
        WHERE balance_at <= :dateMark
        GROUP BY product_id
    ) as tmp_t
ON
    product.id = tmp_t.product_id
INNER JOIN
    balance
ON
    balance.balance_at = tmp_t.max_balance_at AND product.id = balance.product_id;
```

Предзаказы отправляются на склад из магазинов текущим днем, работник склада может увидеть их и выполнить (провести исходящую
проводку) только на следующий день или позднее. Поскольку на некоторые категории товаров (по условию задачи
"Левый носок") количество заявок растет как ряд Фибоначчи (довольно быстрорастущая последовательность), то даже при
единичном количестве в каждой заявке, товар на складе закончится примерно через 2 недели (опять же из количества поставок
из условия задачи). Следовательно, нужно предусмотреть не только невозможность проводки таких предзаказов, но и возможность
висящих предзаказов до пополнения склада. Предзаказы будем складывать в таблицу preorder.

Реализовывать все это будем на фреймворке symfony,
фронт реализуем на vue. Основной критерий выбора стека - скорость и удобство разработки.

# Разворачивание
Клонируте репозиторий, затем выполните команду
```shell
composer install
```
Для подключения к БД откойте файл .env в корне проекта и измените парамеры
подключения на свои:
```dotenv
DB_USER=your_login
DB_PASS=your_password
DB_HOST=127.0.0.1
DB_NAME=your_db_name
```
Вы можете импортировать схему БД из файла schema.sql из корня проекта,
либо выполнить команду в консоли:
```shell
php bin\console doctrine:migrations:migrate
```

Моковые данные находятся в таблице mock.sql. Их можно импортирвать для примера.
Для простоты эксперимента примем не количество заказвов на каждый день, а суммарное количество
единиц во всех заказах на позицию, все равно товара не хватит.
